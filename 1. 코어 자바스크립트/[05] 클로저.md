### 클로저
- **클로저란** 어떤 함수에서 선언한 변수를 참조하는 내부함수를 외부로 전달할 경우, 함수의 실행 컨텍스트가 종료된 후에도 해당 변수가 사라지지 않는 현상
    - 함수 정의 → 정의된 함수의 실행 시점의 상위 스코프(**현재 실행컨텍스트의 렉시컬 환경**) 참조 ⇒ 렉시컬 스코프 → 실행 컨텍스트의 렉시컬 환경은 환경레코드에 현재 컨텍스트와 관련된 코드의 식별자 정보를 저장 ⇒ 호이스팅 → 이 때, 생명 주기가 끝난 변수를 참조하고 있다면 클로저 ..?
- 가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 수집 대상에 포함시키지 않는다.
    - 지역변수를 참조하는 내부함수가 외부로 전달된 경우 가비지컬렉터는 수집하지 않는다.
        
        → 함수는 정의될 때 자신의 내부 슬롯`[[Environment]]`에 자신이 정의될 환경(**상위 스코프의 참조**)을 저장하는데, 그 환경은 현재 실행중인 **실행컨텍스트의 렉시컬 환경**이다. 함수가 중첩되어 있을 때, 외부함수의 생명주기가 끝나더라도 내부함수의 `[Environment]]` 에는 상위 스코프에 대한 참조가 남아있기 때문에 내부에서 참조하는 변수를 가비지컬렉터가 수집하지 않는 것
        
    - 외부 전달이 `return`만을 의미하는 것은 아니다 (외부객체도 포함)
        
        window → setTimeout, setInterval
        
        DOM → EventListener
        
- 왜 상위스코프가 현재 실행 컨텍스트의 렉시컬 환경?
    - 함수 정의가 평가되는 시점은 함수가 정의된 환경인 상위 함수가 실행되고 있는 시점 → 이 때 실행 중인 실행 컨텍스트는 상위 함수의 실행컨텍스트
- 왜 자바스크립트에서 모든 함수가 클로저?
    - 자바스크립트의 모든 함수는 선언 시점에서 상위 스코프를 기억하므로 이론적으로 모든 함수는 클로저라고 할 수 있지만 실제로 상위 스코프의 어떤 식별자도 참조하지 않는경우 대부분의 모던 브라우저는 최적화를 통해 상위 스코프를 기억하지 않기 때문에 클로저라고 볼 수 없다.

### 클로저와 메모리 관리

- 클로저는 개발자의 의도적인 메모리 소모
- 필요성이 사라진 시점에 식별자에 기본형 데이터(`null`)를 할당

### 클로저 활용 사례

- EventListener
    - eventListener의 콜백함수에서 외부 변수를 참조하는 경우
    1. 콜백함수를 리스너의 내부함수로 선언해서 외부변수를 직접 참조
    2. 고차함수의 반환된 함수를 리스너에 콜백 함수로써 전달하여 클로저 활용
        
        → **고차함수**는 함수를 인자로 전달받거나 결과로 반환하는 함수
        
- 정보은닉
    - 어떤 모듈의 내부 로직에 대해 외부로의 노출을 최소화하여 모듈간의 결합도를 낮추고 유연성을 높임
    - 자바스크립트에 기본적으로 설계되어있지 않지만 클로저를 활용하여 구현할 수 있다.
        1. 함수에서 지역변수 및 내부함수 등을 생성
        2. 외부에 제공하고자 하는 정보만 구성된 참조형 데이터(대상이 여러 개일 때는 객체 또는 배열, 하나일 때는 함수)를  `return`
- 부분적용함수(`bind`, `this`관련)
- 커링함수 (지연실행)
    
    ```jsx
    const curry = func => a => b => c => d => e => func(a, b, c, d, e);
    ```
    
    - 당장 필요한 정보만 받아서 전달하다가 마지막 인자가 넘어갈 때까지 함수 실행을 미룬다.
    
    ```jsx
    const getInformation => baseUrl => path => id => fetch(baseUrl + path + '/' + id)
    ```
    
    - 공통 요소는 먼저 기억시켜두고 특정한 값만으로 서버 요청을 수행함으로써 효율성과 가독성을 챙긴다.
    - redux의 미들웨어(`logger`, `thunk`)가 이와 같은 구조
        
        → 두 미들웨어는 공통적으로 `store`, `next`, `action` 순서로 인자를 받는데, `store`와 `next`는 한 번 생성된 이후로 바뀌지 않는 속성이지만 action은 매번 달라짐 → `store`와 `next`값이 결정되면 미리 넘겨서 반환된 함수를 저장시켜놓고 이후에 `action`만 받아서 처리
