### 자바스크립트의 클래스

- 인스턴스: 어떤 클래스의 속성을 지니는 실존하는 개체
- 클래스는 인스턴스 입장에서 직계존속
- 생성자 함수를 new 연산자와 함께 호출하면 인스턴스 생성됨
    - 생성자 함수를 일종의 클래스라고 한다면, 생성자 함수의 `prototype` 객체 내부 요소들이 인스턴스에 ‘상속’ 된다고 볼 수 있음. (프로토타입 체이닝에 의한 참조 결과)
    - `prototype` 프로퍼티를 제외한 나머지는 인스턴스에 상속되지 않음.
        - static methods (인스턴스에 상속되지 않음)
        - prototype methods (인스턴스에 상속)
    - static methods 는 생성자함수를 `this`로 해야만 호출할 수 있다.
        
        ```tsx
        const react = new Rectangle(3, 4)
        
        react.isRectangle(react) //Error
        Rectangle.isRectangle(react) // true
        
        ```
        
- 인스턴스가 사용할 메서드를 정의한 ‘틀’의 역할을 담당하는 목적을 가질 때의 클래스는 추상적 개념
- 클래스 자체를 `this`로 해서 직접 접근해야 하는 스태틱 메서드를 호출할 때의 클래스는 그 자체가 하나의 개체로 취급

### 프로토타입 기반으로 클래스를 구현할 수 있지만 클래스가 등장한 이유?

- 자바나 C#와 같은 클래스 기반 객체지향 프로그래밍에 익숙한 개발자가 빠르게 학습할 수 있도록 등장
- 자바스크립트의 클래스도 함수이며 기존 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있도록 하는 문법적 설탕
- 클래스와 생성자함수는 모두 프로토타입 기반의 인스턴스를 생성하지만 정확히 동일하게 동작하지 않는다. (클래스와 생성자함수의 차이)
    - 클래스는 new 연산자 없이 호출하면 에러가 발생하지만 생성자함수는 일반함수로서 호출된다.
    - 클래스는 상속을 지원하는 `extends`와 `super` 키워드를 제공하지만 생성자함수는 제공하지 않는다.
    - 클래스는 호이스팅이 발생하지 않는 것 처럼 동작하지만 실제로 발생, 함수 선언문으로 정의된 생성자 함수는 함수 호이스팅, 함수 표현식으로 정의된 생성자 함수는 변수 호이스팅이 발생한다.
    - 클래스 내의 모든 코드는 암묵적으로 `strict mode`가 지정되어 실행되고 해제할 수 없지만 생성자 함수는 암묵적으로 `strict mode` 지정되지 않는다.

### 클래스 호이스팅

- 클래스 선언문으로 정의한 클래스는 런타임 이전에 먼저 평가되어 함수 객체를 생성하고, 생성된 함수객체는 생성자 함수로서 호출할 수 있는 함수, `coustructor`이다. 생성자 함수는 함수 객체를 생성하는 시점에 `prototype`도 생성한다. (**클래스는 함수로 평가**된다.)
- 클래스는 함수로 평가되지만 **변수처럼 호이스팅**이된다. → 선언문 이전에 일시적 사각지대(TDZ)에 빠진다.

### 클래스의 constructor

- 생성자함수의 `constructor`와 유사하지만 차이점이 존재
    - 클래스의 `constructor` 는 클래스 내에 **1개만 존재**할 수 있음
    - 클래스의 `constructor` 는 생략이 가능
    - 클래스의 `constructor` 내에서는 인스턴스의 생성과 동시에 인스턴스 프로퍼티 추가를 통해 인스턴스의 초기화를 실행
    - 클래스의 `constructor` 는 별도의 반환문을 갖지 않는다. (암묵적으로 `this`, 즉 인스턴스를 반환)

### 프로토타입 메서드와 정적 메서드

- 클래스 안에서 정의한 메서드는 생성자 함수에 의한 객체 생성 방식과는 다르게 `prototype` 프로퍼티에 메서드를 추가하지 않아도 기본적으로 프로토타입 메서드가 된다.
- 클래스에서 메서드에 `static` 키워드를 붙이면 정적 메서드(클래스 메서드)가 된다.
- 정적 메서드는 프로토타입 메서드처럼 인스턴스로 호출하지 않고 클래스로 호출한다.
- 정적 메서드는 인스턴스로 호출할 수 없다. → 인스턴스의 프로토타입 체인상에 존재하지 않음 (인스턴스에 상속되지 않음)
- 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다.
    - 프로토타입 메서드와 정적 메서드 내부의 `this` 바인딩이 다르다.
        
        프로토타입 메서드→ `this`가 인스턴스를 가르킴
        
        정적 메서드 → `this`가 클래스를 가르킴
        

### 클래스에서 정의한 메서드의 특징

- 메서드 축약 표현 사용
- 객체 리터럴과는 다르게 클래스에 메서드를 정의할 때는 콤마가 필요 없다
- 암묵적으로 strict mode 로 실행
- `for … in` 문이나 `Object.keys` 메서드 등으로 열거할 수 없음.
- non-constructor → `new` 연산자와 호출할 수 없음

### 접근자 프로퍼티

- 접근자 프로퍼티는 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티( `getter`, `setter`)
    - `getter` : 인스턴스 프로퍼티에 **접근** 할 때 마다 프로퍼티의 값을 조작 (메서드 앞에 `get` 키워드 사용)
    - `setter` : 인스턴스 프로퍼티에 값을 할당 할 때 마다 프로퍼티의 값을 조작(메서드 앞에 `set` 키워드 사용)
- 클래스의 메서드는 기본적으로 프로토타입 메서드가 된다 → 클래스의 **접근자 프로퍼티** 또한 인스턴스 프로퍼티가 아닌 **프로토타입 프로퍼티**

### 클래스 필드

- 클래스 몸체 내부에 정의된 속성
- 생성자 밖에서 속성을 정의하고 초기화 할 수 있고, 인스턴스가 생성될 때 자동으로 초기화
- 클래스 필드와 생성자(`constructor`) 차이
    - 클래스 필드를 정의하는 경우 `this` 에 클래스 필드를 바인딩 할 수 없음 . `this`는 `constructor`와 메서드 내에서만 유효
        
        ```tsx
        class Person {
        	// this에 클래스 필드를 바인딩해서는 안된다.
        	this.name = ''; // SyntaxError: Unexpected token '.'
        }
        ```
        
    - 클래스 생성자는 호출 시 값을 전달 받아야 기본값을 설정하지만 클래스 필드는 값을 전달받지 않아도 기본값을 직접 설정할 수 있다.
- 클래스 필드에 함수를 할당하여 메소드를 정의할 수 있다 → 인스턴스 메서드 (모든 클래스 필드는 인스턴스 프로퍼티가 되기 때문) → 권장하지 않음
