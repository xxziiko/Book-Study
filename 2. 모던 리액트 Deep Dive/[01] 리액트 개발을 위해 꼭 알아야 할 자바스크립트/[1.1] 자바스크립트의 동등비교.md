### 1.1 자바스크립트의 동등비교

- 리액트의 의존성 배열이 어떤식으로 작동하는지 렌더링 관점에서 살펴볼 필요가 있다.
- 리액트 컴포넌트의 렌더링이 일어나는 이유 중 하나가 `props`의 동등 비교에 따른 결과이기 때문
- `props`의 동등비교는 **얕은 비교를 기반**으로 이루어지는데, 이를 이해하고 있지 못하면 렌더링 최적화에 어려움을 겪을 가능성이 높다.

<br/>


1. 자바스크립트의 데이터 타입
    1. 원시타입
        1. boolean
        2. null
        3. undefined
        4. number
        5. string
            1. 백틱(``)을 사용한 표현(템플릿 리터럴)과 일반 문자열의 차이 
                
                → 템플릿 리터럴은 줄바꿈이 가능하고 문자열 내부에 표현식을 쓸 수 있다.
                
        6. symbol
            1. ES6에서 새롭게 추가된 타입
            2. 어떤 고유값을 나타내기 위해 사용
        7. bigint
    2. 객체타입
        1. object
            - 배열, 함수, 정규식, 클래스 등이 포함
            - 객체 타입(object type)은 참조를 전달한다고 해서 참조 타입(reference type)이라고도 불린다.
            
            ```tsx
            const hello1 = function() {}
            
            const hello2 = function() {}
            
            hello1 === hello2 // false
            ```
            
            - 객체인 함수의 내용이 육안으로는 같아보여도 참조가 다르기 때문에 `false`
            

<br/>


2. 값을 저장하는 방식의 차이

- 원시 타입과 객체타입의 차이점은 **값을 저장하는 방식의 차이 → 동등비교를 할 때 차이를 만드는 원인**
- 원시타입은 불변 형태의 값으로 저장된다.
- 객체는 프로퍼티를 삭제, 추가, 수정할 여지가 있으므로 원시 값과 다르게 **변경 가능한 형태로 저장**
- 객체 간의 비교는 우리가 이해하는 내부의 값이 같을지라도 결과가 `true`가 아닐 수 있다.

<br/>



3. [`Object.is`](http://Object.is) 와 `===`
    
    ```tsx
    -0 === +0 //true
    Object.is(-0, +0) // false
    
    Number.NaN === NaN // false
    Object.is(Number.NaN, NaN) //true
    ```
    
    - 엄격 동등 연산자(`===`)
        - 숫자와 숫자의 경우, `0`과 `+0`은 같은 값으로 간주되며 `true`를 반환합니다.
        - `NaN`은 어떤 값과도 동등하지 않으며 `false`를 반환합니다. 즉, `Number.NaN === NaN`은 `false`입니다.
    - `Object.is`
        - **`0`과 `+0`:** `Object.is(-0, +0)`는 `false`를 반환합니다. `Object.is`는 `0`과 `+0`을 서로 다른 값으로 간주합니다.
        - **`NaN`**: `Object.is(Number.NaN, NaN)`는 `true`를 반환합니다. `Object.is`는 `NaN`이 자신과 동일하다고 판단합니다. 이는 `NaN`을 `===`에서 특별하게 처리하지 않고, `Object.is`에서 `NaN`을 정확하게 비교할 수 있는 방법을 제공합니다.
    - 그러나 여전히 객체 간 비교에 있어서는 자바스크립트의 특징으로 인해 `===`와 동일하게 동작한다.


<br/>


4. 리액트에서의 동등비교
- 리액트에서는 `objectIs` 를 기반으로 하는 `shallowEqual` 함수를 만들어 사용하며 내부는 `objectIs` 로 비교를 수행한 후, 객체 간 얕은 비교(`1 depth`)를 수행한다.
- 얕은 비교를 구현한 이유는?
    
    → 리액트에서 사용하는 `JSX props`는 객체이고, `props`만 일차적으로 비교하면 되기 때문
    
    → `props`가 깊어지는 경우 동등비교가 `false`로 되기 때문에 `memo`가 작동하지 못하고 렌더링 된다.  
    
    → 만약 이 점을 고려해서 깊은 비교를 하게 된다면(ex 재귀) 렌더링 성능에 악영향을 미칠 것이다. (자바스크립트의 언어적인 한계(?))
    
<br/>


### 정리

- 리액트에서 값의 비교가 어떻게 이루어져서 렌더링 되는지를 숙지하고 있다면, 컴포넌트에서 사용되는 훅의 의존성 배열의 비교, `useMemo`와 `useCallback`의 필요성, 렌더링 최적화를 위한 `React.memo`의 사용에 대해 쉽게 이해할 수 있다.
