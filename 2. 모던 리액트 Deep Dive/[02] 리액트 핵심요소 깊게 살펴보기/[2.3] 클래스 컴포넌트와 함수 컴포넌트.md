### 1. 클래스 컴포넌트

- 기본 구조
  
  클래스를 선언하고 `extends`로 만들고 싶은 컴포넌트를 `extends` 한다.
  
  `extends` 구문에 넣을 수 있는 컴포넌트는 다음과 같다.
  
  - React.Component
  - React.PureComponent
  
  두 컴포넌트의 차이점
  
  - `Component`의 경우 `state`가 업데이트 되는대로 렌더링이 일어나지만 `PureComponent`는 얕은 비교를 수행해 `state` 값이 다를때만 렌더링을 수행
- 구성 요소
  - `constructor()` : 컴포넌트가 초기화 되는 시점에 호출되며 컴포넌트의 `state`를 초기화할 뿐 아니라 `super()`를 이용하여 상속받은 상위 컴포넌트에 접근할 수도 있다.
      
      → ES2022에 추가된 클래스 필드 분법은 별도의 초기화 과정을 거치지 않고 클래스 내부에 필드를 선언할 수 있게 도와준다. ES2022를 지원하는 브라우저에서만 제공하나 바벨의 `@babel/plugin-proposal-class-properties` 를 사용해 트랜스 파일을 거치면 사용할 수 있다.
      
  - `props`: 컴포넌트에 특정 속성을 전달하는 용도
  - `state`: 클래스 컴포넌트 내부에서 관리하는 값. 이 값은 항상 객체여야 하며 값에 변화가 있을 때 마다 리렌더링이 발생
  - 메서드: 렌더링 함수 내부에서 사용되며 보통 DOM에서 발생하는 이벤트와 함께 사용
      
      메서드 사용 방법
      
      - `contructor`에서 `this` 바인딩: 생성된 함수에 `bind`를 활용해 강제로 this를 바인딩 하여 사용해야 한다. 그렇지 않으면 `this`가 `undefined`로 나오는 현상을 겪는다. 이유는 생성자가 아닌 일반함수로 호출하게 되면 this에 전역객체가 바인딩되기 때문
      - 화살표 함수를 쓰는 방법: 화살표 함수는 작성 시점에서 `this`가 상위 스코프로 결정되기 때문에 굳이 바인딩하지 않더라도 사용할 수 있음
      - 렌더링 함수 낸부에서 함수를 새롭게 만들어 전달하는 방법: 이 방법은 매번 렌더링이 일어날 때 마다 새로운 함수를 생성해 할당하므로 최적화 수행하기 어렵기 때문에 지양하는 방법이다.
          
          ```tsx
          <button onClick={() => this.handleClick()}>증가</button>
          ```
          
  

**클래스 컴포넌트의 생명주기 메서드**

- 생명주기 메서드가 실행되는 시점
  - 마운트(`mount`): 컴포넌트가 생성(`mount`)되는 시점
  - 업데이트(`update`): 이미 생성된 컴포넌트의 내용이 변경(`update`)되는 시점
  - 언마운트(`unmount`): 컴포넌트가 더 이상 존재하지 않는 시점
- `render()`
  
  컴포넌트가 UI를 렌더링하기 위해 쓰임.
  
  이 함수는 항상 순수해야 하며 부수효과가 없어야 한다.(no side-effects)
  
  → 같은 입력값(`props` or `state`)이 들어가면 항상 같은 결과물을 반환해야 한다.
  
  따라서, `this.setState`를 호출하면 안되고 `state`를 변경하는 일은 클래스 컴포넌트의 메서드나 다른 생명주기에서 이루어져야함
  
- `componentDidMount()`
  
  클래스 컴포넌트가 마운트되고 나서 호출되는 생명주기 메서드이며 컴포넌트가 마운트되고 준비되는 즉시 실행
  
  일반적으로 state를 다루는 것은 생성자에서 하는 것이 좋다.(성능 문제)
  
  → componentDidMount에서 this.setState를 허용하는 것은 생성자 함수에서 할 수 없는것(API 호출 후 업데이트, 이벤트 리스너 추가 등)을 하는경우
  
- `componentWillUnmount()`
  
  컴포넌트가 언마운트되거나 더이상 사용되지 않기 직전에 호출된다.
  
  메모리 누수나 불필요한 작동을 막기 위한 클린업 함수를 호출하기 좋은 위치이며 이 메서드 내에서 `this.setState`를 호출할 수 없다.
  
- `shouldComponentUpdate()`
  
  `state`나 `props`의 변경으로 리렌더링 되는 것을 막을 때 사용한다.
  
  일반적으로 state의 변화에 따라 컴포넌트가 리렌더링 되는 것은 자연스러운 일이기 때문에 특정한 성능 최적화 상황에서만 고려해야한다. 
  
- `static getDerivedStateFromProps()`
  
  사라진 `componentWillReceiveProps`를 대체할 수 있는 메서드이며 static으로 선언되어있어 `this`에 접근할 수 없다.
  
- `getSnapShotBeforeUpdate()`
  
  업데이트 되기 전에 호출, 반환 값은 componentDidUpdate로 전달된다.
  
  DOM에 렌더링 되기 전에 윈도우 크기를 조절하거나 스크롤 위치 조정 작업 처리에 유용
  
- `getDerivedStateFromError`
  
  `state` 메서드로, `error`를 인수로 받으며 `error`는 하위 컴포넌트에서 발생한 에러를 말한다. 
  
  하위컴포넌트에서 에러가 발생했을 경우의 리액트 컴포넌트 렌더링을 결정하는 용도로 제공되는 메서드이기 때문에 반드시 정의해둔 `state` 값을 반환해야 한다.

  <aside>
      
      💡  getDerivedStateFromError 에서 부수효과를 추가한다고 에러가 발생하지 않지만,
          render단계에서 호출되기 때문에 렌더링 과정을 불필요하게 방해할 수 있어서 console.error와 같은 로깅 작업을 포함한 부수효과를 발생시키는
          요소들을 추가하는 것을 지양한다.
  </aside>
  
    - `componetDispatch` : 자식 컴포넌트에서 에러가 발생했을 때, `getDerivedStateFromError`  에서 에러를 잡고 `state` 결정 후에 실행
    - 에러 발생 시, 이 메서드에서 제공하는 정보를 바탕으로 로깅하는 용도로 사용

- `getDerivedStateFromError`  와 `componetDispatch` 메서드는 `ErrorBoundary` 컴포넌트를 만들기 위한 목적으로 많이 사용된다. 그러나 모든 에러를 잡는 것은 아니며 경계 외부에서 발생한 에러는 잡을 수 없다.
- `ErrorBoundary` 에서 주의할 점: `componetDispatch` 는 개발모드와 프로덕션 모드에서 다르게 작동한다. 개발모드에서는 window까지 에러가 전파되지만 프로덕션 모드는 `componetDispatch` 에서 잡하지 않은 에러만 window까지 전파된다.

**클래스 컴포넌트의 한계**

- 데이터의 흐름을 추적하기 어려움
  
  생명주기 메서드는 state의 흐름을 파악하기 어렵고, 메서드의 순서가 강제되어있지 않기 때문에 개발자가 어떤 흐름으로 렌더링이 일어나는지 파악하는 것이 어려움
  
- 애플리케이션 내부 로직의 재사용의 어려움
  
  컴포넌트 사이즈가 커지거나 중복되는 로직이 많아질 수록 이를 감싸는 고차 컴포넌트 내지는 `props`가 많아지는 래퍼 지옥에 빠질 수 있음.
  
- 기능이 많아질수록 컴포넌트 크기가 커진다
- 함수에 비해 상대적으로 어려고 코드 크기를 최적화 하기 어렵다.
- 핫 리로딩에 불리하다.
  
  핫 리로딩이란 코드에 변경사항이 발생했을때 앱을 다시 시작하지 않아도 해당 변경된 코드만 업데이트하여 변경사항을 빠르게 적용하는 기법 (개발단계에서 많이 사용됨)
  
  클래스 컴포넌트는 핫 리로딩이 일어나면 `state`가 초기화된다. 
  
  이유는 클래스 컴포넌트는 최초 렌더링 시에 인스턴스를 생성하고 값을 관리하는데, 인스턴스 내부에 있는 `render`를 수정하면 이를 반영하기 위해 인스턴스를 다시 만들기 때문에 값이 초기화된다. 
  
  반면 함수형 컴포넌트는 `state`를 함수가 아닌 클로저에서 저장하기 때문에 값을 잃지 않는다. 

<br/>
  

### 2. 함수 컴포넌트

- 16.8 이전에는 단순히 무상태 컴포넌트를 구현하기 위한 수단이었다.
- `this`를 사용하지 않고 `props`와 `state`에 접근하고, `render` 내부에 필요한 함수를 선언할 때도 신경쓰지 않아도 되는 등의 편리함이 있다.

<br/>

### 3. 함수 컴포넌트 vs 클래스 컴포넌트

1. 생명주기 매서드 부재
    -  함수형 컴포넌트에서 `useEffect` 훅을 사용해 생명주기 메서드를 비슷하게 구현할수는 있지만 완전히 똑같은 것은 아니다.
    -   `useEffect` 는 생명주기를 위한 훅이 아니라 `state`를 활용해 동기적으로 부수효과를 만들어내는 메커니즘이다
2. 함수 컴포넌트와 렌더링 된 값
    - 클래스 컴포넌트는 `props`의 값을 항상 `this`로 부터 가져오는데, 이는 외부에서 변경되지 않는 이상 불변값이지만 `this`가 가르키는 컴포넌트의 인스턴스 멤버는 변경 가능(mutable)한 값이기 때문에 생명주기 메서드가 변경된 값을 읽을 수 있게 된다. 
      → 부모 컴포넌트가 `props`를 변경해 컴포넌트가 다시 렌더링 된다는 것은 `this.props`의 값이 변경된 것이기 때문에 새로운 값을 읽는다. 
    - 반면에 함수 컴포넌트는 `props`를 인수로 받기 때문에 해당 값을 그대로 사용하게 된다. (`state`도 마찬가지) 

<br/>

  정리 
  
  클래스 컴포넌트는 `props`의 값을 `this`로부터 가져오기 때문에 렌더링 시 최신의 `this.props`와 `this.state`를 기준으로 렌더링이 일어나지만, 함수 컴포넌트는 렌더링 시 그 순간의 값인 `state`와 `props`를 기준으로 렌더링된다.
