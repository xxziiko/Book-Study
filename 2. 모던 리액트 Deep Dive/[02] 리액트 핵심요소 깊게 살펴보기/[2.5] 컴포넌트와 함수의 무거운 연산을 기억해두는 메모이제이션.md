### 2.5 컴포넌트와 함수의 무거운 연산을 기억해두는 메모이제이션

1. 필요한 곳에만 메모이제이션을 추가하자
- 메모이제이션에도 비용이 든다.
    - 렌더링 또는 재계산이 필요한지 확인하는 작업
    - 이전에 결과물을 저장해 두었다가 다시 꺼내오는 작업
- 메모이제이션의 비용이 렌더링 비용보다 항상 저렴하다고 할 수 있을까?
    
    → 그렇다면, 모든 컴포넌트를 PureComponent로 만들었거나 `memo`로 감싸는 작업을 했을 것이며 개발자에게 선택권을 주지 않았을 것. → 이 사실은 메모이제이션이 모든 문제를 해결할수 없다는 것을 방증하는 것
    
- 리액트 공식 문서에서는 `useMemo`의 최적화 지원 보장에 대해 언급하고 있다. → 섣불리 최적화하는 것은 옳지 못함
- `useEffect`를 사용하여 렌더링 상황을 파악하고, 필요한 경우에만 메모이제이션을 적용하는 것이 좋다.

<br />

2. 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션하자
- 잘못된 `memo`로 지불해야하는 비용은 `props`에 대한 얕은 비교 발생 비용
- `memo` 를 하지 않았을 때 발생할 수 있는 비용은 훨씬 더 크다
    - 리렌더링 비용
    - 컴포넌트 내부의 복잡한 로직 재실행, 트리구조의 연쇄적인 적용
    - 구 트리와 신규 트리의 비교

→ `memo`를 하지 않았을 때의 잠재적인 위험비용이 더 크다.

- `useCallback`과 `useMemo`는?
- 의존성 배열을 비교하고, 값을 재계산하는 비용 vs 값과 함수를 매번 재생성하는 비용
- 값과 함수를 매번 재생성한다면 참조가 달라진다 → 달라진 참조가 `useEffect`와 같은 곳에 쓰인다면 문제가 된다. → 객체 내부의 값은 같더라도 참조가 변경되기 때문이다.
- 즉 `useCallback`, `useMemo`를 사용하는 것이 참조의 투명성을 유지함
- 메모이제이션을 모두 하지 않았을때보다 모두 하는 것이 이점이 더 많다.

### 결론

- `props`에 대한 얕은 비교를 수행하는 것보다 리액트 컴포넌트의 결과물을 다시 계산하고 실제 DOM까지 비교하는 작업이 더 무겁고 비싸다. 그렇기 때문에 조금이라도 로직이 들어갔다면 메모이제이션이 성능 향상에 도움을 될 가능성이 높다.
- `useCallback`, `useMemo` 도 대부분 다른 컴포넌트의 `prop`로 넘어가는 경우가 많은데 참조 투명성을 유지하기 위해서는 두 훅을 사용하는 것이 최적화에 도움이 될 수 있다.
