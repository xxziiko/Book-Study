### 3.1 리액트의 모든 훅 파헤치기

1. `useState`
    - 리액트의 렌더링은 함수 컴포넌트에서 반환한 결과물인 `return`의 값을 비교해 실행한다.
    - 즉, 매번 렌더링이 발생될 때 마다 함수는 다시 새롭게 실행되고 `state`는 매번 초기화된다.
    - `useState`는 내부적으로 클로저를 활용하여 상태 업데이트 함수가 선언된 스코프에서 이전 상태를 참조할 수 있게 한다. → 함수 컴포넌트가 계속 리렌더링 되어도 상태(값)를 유지할 수 있는 이유이다.
    - 게으른 초기화
        
        ```tsx
        const [count, setCount] = useState(
        () => Number.parseInt(window.localStorage.getItem(cacheKey)),
        )
        ```
        
        - 리액트 공식 문서에서 게으른 초기화는 `useState`의 초기값이 복잡하거나 무거운 연산을 포함하고 있을때 사용하라고 권장한다. (localStorage나 sessionStorage에 대한 접근, `map`, `filter`, `find`와 같은 배열에 대한 접근 등)
        - 게으른 초기화 함수는 오로지 `state`가 처음 만들어질때만 사용된다.

<br/>
<br/>

2. `useEffect`
    - 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수효과를 만드는 메커니즘 (생명주기 메서드를 대체하기 위해 만들어진 것이 아님)
    - 렌더링 할 때마다 의존성에 있는 값을 보면서 이전과 다른 값이 있다면 부수효과를 실행
    - **클린업 함수의 목적**: `useEffect`의 콜백이 실행될 때마다 이전의 클린업 함수가 존재한다면 클린업 함수를 실행한 뒤 콜백을 실행한다. → 이벤트 핸들러가 무한히 추가되는 것을 방지
    - **언마운트와 클린업 함수의 차이점**: 언마운트는 특정 컴포넌트가 DOM에서 사라지는 것을 의미하는 클래스 컴포넌트의 용어이며 클린업 함수는 함수 컴포넌트가 리렌더링 되었을 때 의존성 변화의 이전의 값을 기준으로 실행된다.
    - `useEffect` 는 컴포넌트 렌더링의 부수효과이기 때문에 **렌더링이 완료된 이후에 실행**된다.
    - `useEffect` 는 반드시 의존성 배열로 전달한 값의 변경에 의해 실행되어야 한다. 그렇지 않을 경우, 실제로 관찰해서 실행되어야 하는 값과 별개로 부수효과가 발생할 수 있다. (개발자의 의도와 다르게 실행될 수 있음)
    - `useEffect` 의 첫번째 인자인 콜백함수를 기명함수로 작성하면 해당 함수의 의도를 좀 더 직관적으로 알 수 있다.
    - `useEffect` 를 사용할 때는 최대한 작은 단위로 적은 의존성 배열을 사용하는 여러개의 `useEffect`으로 분리하는 것이 좋다.
    - `useEffect` 내에서 사용되는 부수효과라면 내부에서 정의하여 관리하는 것이 좋다.

<br/>
<br/>

3. `useMemo`
    - 렌더링 발생 시 의존성 배열의 값이 변경되지 않았으면 이전에 저장해둔 값을 반환하고, 의존성 배열의 값이 변경되었다면 첫번째 인수의 함수를 실행하여 그 값을 반환하고 그 값을 기억해둔다.
    - 어떤 값을 계산할 때 해당값을 연산하는 비용이 많이 든다면 사용하기에 바람직하다.

<br/>
<br/>


4. `useCallback`
    - `useCallback` 는 인수로 넘겨받은 콜백 자체를 기억 → 함수를 새로 만들지 않고 재사용
    - 해당하는 의존성이 변경됐을 때만 함수가 재생성

<br/>
<br/>


5. `useRef`

    - 반환값인 객체 내부에 있는 `current`로 값에 접근하거나 변경이 가능하며 그 값이 변하더라도 렌더링을 발생시키지 않는다.
    - 개발자가 원하는 시점의 값을 렌더링에 영향을 받지 않고 보관해두고 싶을때 사용하면 용이

<br/>
<br/>

6. `useContext`
    - `useContext` 를 사용한다면 재사용이 어려워진다는 점을 염두해야 한다. (Provider에 의존성을 가지게 되기 때문)
    - `useContext` 를 사용하는 컴포넌트를 최대한 작게 하거나 재사용되지 않을 컴포넌트에 사용하는 것이 좋다
    - `context`는 상태를 관리하는 API가 아니라 상태를 주입해주는 API이다.
        - 상태관리 라이브러리가 되기 위해서는 어떤 상태를 기반으로 다른 상태를 만들어 낼 수 있거나, 필요에 따라 상태변화를 최적화 할 수 있어야 하는데 `context`는 둘 다 해당하지 않는다.
        - 단순히 `props`를 하위로 전달하는 역할만 할 뿐이지 렌더링이 최적화되지 않는다.

<br/>
<br/>

7. `useReducer`
    - 복잡한 형태의 `state`를 사전에 정의된 `dispatcher`로만 수정할 수 있게 만들어서 `state` 값에 대한 접근은 컴포넌트에서만 가능하게 하고, 이를 업데이트 하는 상세 정의는 컴포넌트 밖에 두어 미리 정의해둔 `dispatcher`로만 `state` 업데이트를 제한하는 것이다.
    - `useReducer`의 목적은 `state` 값을 변경하는 시나리오를 제한적으로 두어 이에 대한 변경을 빠르게 확인하기 위함이다.
    - `useReducer` 를 사용하면 `state`를 사용하는 로직과 이를 관리하는 비즈니스 로직을 분리할 수 있어 복잡해지는 `state`를 관리하기 쉬워진다.

<br/>
<br/>

8. `useImperativeHandle`
    - 리액트에서 `ref`를 `props`로 사용할 수 없다(`undefined` 반환 경고 문구) → `forwardRef` 는 ref를 전달하는 것에 관해 **일관성을 제공**하기 위함이다. (`ref` 에 대한 `props` 네이밍 자유도를 제한하여 예측성을 높이기 위함)
    - `useImperativeHandle` 는 부모가 자식 컴포넌트에서 새롭게 설정한 객체의 키와 값에 대해서 접근 가능하게 해주는 훅

<br/>
<br/>

9. `useLayoutEffect`
    - 함수의 시그니처는 `useEffect` 와 동일하나 차이점은 `useLayoutEffect` 는 모든 DOM 변경 후에 `useLayoutEffect` 의 콜백 함수 실행이 동기적으로 발생한다는 점이다.
    - DOM의 변경은 브라우저에 변경사항이 반영되는 시점이 아니라, **렌더링**이다.
        - 리액트가 DOM 을 업데이트
        - `useLayoutEffect` 실행
        - 브라우저에 변경 사항을 반영
        - `useEffect` 를 실행
    - DOM은 계산되었지만 이것이 화면에 반영되기 전에 하고 싶은 작업이 있을 때 사용하기 적절 → 특정 요소에 따라 DOM요소를 기반으로 한 애니메이션, 스크롤 위치 제어 등

<br/>
<br/>

10. `useDebugValue`
    - 디버깅 하고 싶은 정보를 리액트 개발자 도구에서 볼 수 있음
    - 다른 훅 내부에서만 실행할 수 있음(컴포넌트 레벨에서 실행한다면 작동하지 않는다.)
    - 공통 훅을 제공하는 라이브러리나 대규모 에플리케이션에서의 디버깅에 유용

<br/>
<br/>

11. 훅의 규칙
    - 최상위에서만 훅을 호출해야 하며 반복문이나 조건문, 중첩된 함수 내에서 훅을 실행할 수 없다. → 렌더링 이후에 동일한 순서로 훅이 호출되는 것을 보장하기 위함임.
    - 훅을 호출할수 있는 것은 리액트 함수 컴포넌트 혹은 사용자 정의 훅 두 가지 경우이며, 일반 자바스크립트 함수에서는 훅을 사용할 수 없다.
