### ‘상태’란?

어떠한 의미를 지닌 값이며 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값

- UI, URL, form, API요청 등

### 리액트 상태 관리의 역사

  1. Flux 패턴
      - 페이스북팀은 복잡해지는 상태관리의 어려움을 양방향 데이터 바인딩으로 판단
          
          → 양방향 데이터 바인딩은 코드의 예측성이 떨어지고 변경 시나리오가 복잡해질수록 상태관리가 어려워짐
          
      - 단방향으로 변경
      - action : 어떤 작업을 처리할 액션과 그 액션 발생시 함께 포함시킬 데이터
      - dispatch : 액션을 스토어에 보내며 콜백함수 형태로 액션이 정의한 타입과 데이터를 스토어에 보냄
      - store : 실제 상태에 따른 값과 상태를 변경할 수 있는 메서드가 존재
      - view : 리액트의 컴포넌트에 해당
      - 리액트도 단방향 데이터 바인딩을 기반으로 한 라이브러리이기 때문에 Flux 패턴과 궁합이 잘 맞음
<br/>

  2. 리덕스 → Flux + Elm아키텍처 도입
      - Elm : 웹페이지를 선언적으로 작성하기 위한 언어
      - 하나의 상태 객체를 스토어에 저장해 전역적으로 관리한다.
      - 많은 보일러플레이트 코드
<br/>

  3. Context API와 useContext
      - Context API는 컴포넌트 간 상태를 효율적으로 전달하기 위한 도구로 만들어졌으며, 주된 목적은 상태의 주입(injection)이다.
      - Context API만으로는 상태 업데이트에 대한 렌더링 최적화를 보장하지 않는다
<br/>

  4. 훅의 탄생, React Query와 SWR
      - React Query와 SWR는 외부에서 데이터를 불러오는 비동기 데이터 요청(fetch)을 관리하기에 최적화되어있다.
      - **캐싱**을 통해 데이터의 재사용과 네트워크 요청을 최소화하여 성능을 개선
<br/>

  5. Recoil, Zustand, Jotai, Valtio
      - React Query나 SWR보다 더 **범용적인 상태 관리**에 사용
      - 기존의 Redux와 같은 전역 상태 관리에서 겪었던 복잡함과 성능 문제를 작은 크기의 상태로 분리해 컴포넌트 수준에서 효율적으로 관리
