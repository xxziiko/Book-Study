## 2. 리액트 서버 컴포넌트


### 1. 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

- 자바스크립트 번들 크기가 0인 컴포넌트를 만들 수 없음
    - 타사 라이브러리의 사용은 사용자 기기 부담으로 이어짐
    - 만약 라이브러리는 서버만 가지고 있고, 서버에서는 해당 라이브러리를 실행한 결과와 컴포넌트 렌더링 결과물을 클라이언트에 제공한다면?
- 백엔드 리소스에 직접적인 접근이 불가능
    - 클라이언트에서 백엔드에 접근하려면 REST API와 같은 방법을 사용하는 것이 일반적
    - 백엔드에서 항상 클라이언트에서의 데이터 접근을 위한 방법을 마련해야하는 불편함 존재
    - 클라이언트에서 직접 데이터에 엑세스한다면 이러한 수고로움이 줄어듦
- 자동 코드 분할(code spllit)이 불가능
    - 코드 분할이란 코드를 여러 작은 단위로 나누어 필요할 때만 동적으로 지연 로딩함으로써 앱의 초기화 속도를 높여주는 기법. 리액트에서는 lazy를 사용해 구현
    - 코드 분할을 서버에서 자동으로 수행한다면 코드 분할의 이점을 확실하게 누릴 수 있음
        - 자동화된 코드분할, 서버 사이드에서의 코드 실행으로 인한  최적화, 데이터 패칭과 렌더링의 결합 등
- 연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어려움
    - 최초 컴포넌트의 요청과 렌더링이 끝나기 전까지는 하위 컴포넌트의 요청과 렌더링이 끝나지 않는 단점, 서버 요청이 지연됨으로써 컴포넌트 결과물에 의존하는 하위 컴포넌트들의 loading상태의 렌더링을 추가적으로 발생시키는 단점이 존재
    - 이러한 작업을 서버에서 수행한다면 데이터를 불러오고 렌더링 하는 과정이 모두 서버에서 실행되므로 클라이언트에서 서버로 요청함으로써 발생하는 지연을 줄일 수 있고, 반복적인 요청을 수행할 필요가 없어진다.
- 추상화에 드는 비용이 증가한다.
    - 자바스크립트를 기반으로 하기 때문에 자유도가 높아 추상화가 복잡해질수록 코드의 양은 많아지고, 런타임 시 오버헤드 발생

<br />


→ 리액트가 클라이언트 중심으로 돌아가기 때문에 발생하는 한계점들

→ 성능을 위해 클라이언트의 역할을 일부 희생? 혹은 다양한 사용자 경험을 위해 일부 성능을 희생하여 클라이언트에서 다양한 작업을 처리?

<br />


### 2. 서버 컴포넌트란?

- 하나의 언어, 하나의 프레임워크, 하나의 API와 개념을 사용하면서 서버와 클라이언트 모두에서 컴포넌트를 렌더링 할 수 있는 기법
- 일부는 서버에서, 일부는 클라이언트에서 렌더링
- 클라이언트 컴포넌트는 서버 컴포넌트를 import 할 수 없다. → 브라우저에는 nodejs환경이 존재하지 않기 때문

<br />


**서버 컴포넌트, 클라이언트 컴포넌트, 공용 컴포넌트의 차이**

- 서버 컴포넌트
    - 요청이 오면 그 순간 서버에서 한 번만 실행되기 때문에 상태를 가질 수 없다. 따라서 상태를 가질 수 있는 useState, useReducer와 같은 훅을 사용할 수 없음
    - 마찬가지로 렌더링 생명주기도 사용할 수 없다. useEffect 와 같은 훅 사용할 수 없다.
    - effect나 state에 의존하는 사용자 정의 훅 또한 사용할 수 없음. (의존하지 않고 서버에서만 제공할 수 있는 기능을 사용하는 훅이라면 사용 가능)
    - 서버에서만 실행되기 때문에 window. document등에 접근할 수 없음
    - 데이터 베이스, 내부 서비스, 파일 시스템 등 서버에만 있는 데이터를 async/await 으로 접근할 수 있고 컴포넌트 자체가 async한 것이 가능
    - 다른 서버 컴포넌트를 렌더링 하거나 div, span, p 와 같은 요소를 렌더링하거나 클라이언트 컴포넌트를 렌더링 할 수 있다.
- 클라이언트 컴포넌트
    - 서버 컴포넌트를 불러오거나 서버 전용 훅이나 유틸리티를 불러올 수 없다.
    - 서버 컴포넌트가 클라이언트 컴포넌트를 자식으로 가질 수 있으며, 이 경우 서버 컴포넌트가 먼저 렌더링한 결과물을 클라이언트 컴포넌트가 받아 삽입하여 보여준다.
    - 나머지는 일반적인 리액트 컴포넌트와 같다
    - 클라이언트 컴포넌트라는 것을 명시적으로 선언하려면 맨 윗줄에 “use client” 라고 작성
- 공용 컴포넌트
    - 서버와 클라이언트에서 모두 사용 가능하며 공통으로 사용할 수 있기 때문에 모든 제약을 받는 컴포넌트가 됨
- 리액트는 기본적으로 모든 컴포넌트를 다 서버에서 실행 가능한 것으로 분류하고, 클라이언트 컴포넌트라는 것을 명시적으로 선언하려면 맨 윗줄에 “use client” 라고 작성

<br />

### 3. 서버 사이드 렌더링과 서버 컴포넌트의 차이

- 서버 사이드 렌더링
    - 응답받은 페이지 전체를 **HTML로 렌더링 하는 과정을 서버에서 수행**한 후 그 결과를 클라이언트에게 전달
    - 이 후 클라이언트에서 하이드레이션 과정을 고쳐 서버의 결과물을 확인하고 이벤트를 붙이는 작업을 수행
    - 서버 사이드 렌더링의 목적은 초기 인터렉션은 불가능 하지만 정적인 HTML를 빠르게 내려주기 위함
    - 따라서 서버사이드 렌더링은 HTML로딩 이후의 자바스크립트 실행은 비용이 든다.
- 서버 컴포넌트
    - 서버에서 컴포넌트를 렌더링하고 결과를 HTML로 전송
    - 서버 컴포넌트는 클라이언트에 JavaScript 번들을 전송하지 않음
    - 클라이언트로 전송되는 JavaScript 크기를 줄여 성능 최적화
    - 서버에서 데이터를 처리하고, 클라이언트에 최소 데이터 전송

<br />

### 4. 서버 컴포넌트는 어떻게 작동하는가?

1. 서버가 렌더링 요청을 받는다. 서버가 렌더링 과정을 수행해야 하기 때문에 리액트 서버 컴포넌트를 사용하는 모든 페이지는 항상 서버에서 시작된다. 
2. 서버는 받는 요청에 따라 컴포넌트를 **JSON으로 직렬화**한다. 서버에서 렌더링 할 수 있는 것은 직렬화 하고, 클라이언트 컴포넌트로 표시된 부분은 플레이스 홀더 형식으로 비워두고 나타냄. 브라우저는 이후에 이 결과물을 받아서 역직렬화한 후 렌더링을 수행
3. 브라우저가 리액트 컴포넌트 트리를 구성한다. 브라우저가 서버로 스트리밍으로 JSON 결과물을 받았다면 이 구문을 다시 파싱한 결과물을 바탕으로 트리를 재구성해 컴포넌트를 만들어 나간다. 
4. 최종적으로 이 트리를 렌더링해 브라우저의 DOM에 커밋
