## 3.Next.js에서의 리액트 서버 컴포넌트

### 1. fetch 도입과 getServerSideProps, getStaticProps, getInitialProps의 삭제

- 13버전부터 모든 데이터 요청은 웹에서 제공하는 표준 API인 fetch를 기반으로 이루어짐
- getServerSideProps는 서버 사이드 렌더링만을 위한 것이었는데, 서버 컴포넌트 페이지에서 fetch함으로써 getServerSideProps를 사용하지 않고 서버에서 직접 데이터를 불러올 수 있게 됐으며 컴포넌트가 비동기적으로 작동하는 것도 가능해졌다.
- fetch 요청에 대한 내용을 서버에서 캐싱하며, 클라이언트에서 별도의 요청이 없으면 해당 데이터를 최대한 캐싱해 중복된 요청을 방지한다.

<br />

### 2. 정적 렌더링과 동적 렌더링

- 서버에서 불러오는 데이터가 정적이라면 getStaticProps 를 활용해 정적으로 페이지를 만들어 제공할 수 있었음 → CDN에서 캐싱해 기존 서버 사이드 렌더링보다 더 빠른 데이터 제공
- 13 이상부터는 정적인 라우팅에 대해서 기본적으로 빌드 타임에 미리 렌더링하여 캐싱해두고, 동적인 라우팅에 대해서는 서버에 매번 요청이 올 때마다 렌더링하도록 변경. 이때, fetch의 캐시 옵션을 활용하여 요청 결과를 캐싱
- next/header나 next/cookie와 같은 헤더 정보와 쿠키 정보를 불러오는 함수를 사용하게 된다면 해당 함수는 동적인 연산을 바탕으로 반환하기 때문에 정적 렌더링 대상에서 제외됨

<br />

### 3. 캐시와 mutating, 그리고 revalidating

- fetch의 옵션으로 revalidate를 설정할 수 있는데, 이는 페이지에 revalidate라는 변수를 선언해서 페이지 레벨로 정의하는 것도 가능
- 루트에 revalidate를 선언하면 하위에 있는 모든 라우팅에 적용되어 렌더링된다.
- 캐시와 갱신이 이루어지는 과정
    - 최초로 해당 라우트에 요청이 올 때는 미리 정적으로 캐시해 둔 데이터를 보여줌
    - 이 캐시된 초기 요청은 revalidate에 선언된 값 만큼 유지
    - 만약 해당 시간이 지나도 일단은 캐시된 데이터를 보여준다.
    - Next.js는 캐시된 데이터를 보여주는 한편, 시간이 경과했으므로 백그라운드에서 다시 데이터를 업데이트
    - 해당 작업이 성공적으로 끝나면 캐시를 갱신, 그렇지 않으면 캐시를 재사용
- 캐시를 무효화 하고 싶다면 router에 추가된 refresh 메서드 사용 → 브라우저의 히스토리에 영향을 미치지 않고 오직 서버에서 루트부터 데이터를 가져와 갱신, 브라우저나 리액트의 상태에 영향을 주지 않음

<br />

### 4. 스트리밍을 활용한 점진적 페이지 불러오기

- 경로에 loading.tsx 배치: 예악어로 존재하는 Loading 컴포넌트를 렌더링이 완료되기 전에 보여줌(Loading은 Suspense를 기반으로 만들어진 Nextjs의 규칙)
- React Suspense 배치: React에서 제공하는 Suspense를 배치하여 좀 더 세분화된 제어를 할 수 있음
