## 1. 타입이란

### 자료형으로서의 타입

- undefined
- null
- Boolean
- Symbol
- String
- Numeric(Number, BigInt)
- Object
- 데이터 타입은 여러 종류의 데이터를 식별하는 분류 체계로 컴파일러에 값의 형태를 알려준다.
- 메모리 관점에서의 데이터 타입은 프로그래밍 언어에서 일반적으로 타입으로 부르는 개념과 같다.

### 집합으로서의 타입

- 프로그래밍에서의 타입은 값이 가질 수 있는 유효한 범위의 집합
- 타입 시스템은 코드에서 사용되는 유효한 값의 범위를 제한해서 런타임에서 발생할 수 있는 유효하지 않은 값에 대한 에러를 방지
- 타입을 제한하면 타입스크립트 컴파일러는 함수를 호출할 때 호환되는 인자로 호출했는지 판단 후 컴파일

### 정적 타입과 동적 타입

타입을 결정하는 시점에 따라 타입을 정적 타입과 동적 타입으로 분류할 수 있다.

- 정적 타입 시스템에서는 모든 변수의 타입이 컴파일타임에 결정
- C, 자바, 타입스크립트 등이 정적 타입 언어에 속함
- 동적 타입 시스템에서는 변수 타입이 런타임에서 결정
- 파이썬, 자바스크립트가 동적 타입 언어에 속함

### 강타입과 약타입

- 압묵적 타입 변환: 개발자가 의도적으로 타입을 명시하거나 바꾸지 않았지만 컴파일러 또는 엔진 등에 의해서 런타임에 타입이 자동으로 변경되는 것
- 강타입 특징을 가진 언어는 서로 다른 타입을 갖는 값끼리 연산을 시도하면 컴파일러 또는 인터프리터에서 에러가 발생
- 약타입 특징을 가진 언어에서 서로 다른 타입을 갖는 값끼리 연산할 때는 컴파일러 또는 인터프리터가 내부적으로 판단하여 특정 값의 타입을 변환하여 연산을 수행
- 압묵적 타입 변환은 개발자가 명시적으로 타입을 변환하지 않아도 다른 데이터 타입끼리 연산을 진행할 수 있는 편리함을 제공하지만, 작성자의 의도와 다르게 동작할 수 있어 예기치 못한 오류가 발생할 가능성이 있다.
- 자바스크립트는 약타입 언어이기 때문에 런타임에서 발생할 수 있는 에러를 예측하고 방지하는 코드를 작성하는 것이 프로그램을 안전하게 만드는 데 도움이 된다.
- “안전한”이라는 표현은 타입 안정성을 의미한다.

### 컴파일 방식

- 컴파일은 사람이 이해할수 있는 방식으로 작성한 코드를 컴퓨터가 이해할 수 있는 기계어로 바꿔주는 과정
- 타입스크립트의 컴파일 결과물은 사람이 이해할 수 있는 자바스크립트 파일
- 타입스크립트가 탄생한 이유는 자바스크립트의 컴파일타임에 런타임 에러를 사전에 방지하기 위한 것

  <br/>

## 2. 타입스크립트의 타입 시스템

### 타입 애너테이션 방식

- 타입 애너테이션이란 변수나 상수 혹은 함수의 인자와 반환 값에 타입을 명시적으로 선언해서 어떤 타입 값이 저장될 것인지를 컴파일러에 직접 알려주는 문법
- 타입스크립트에서는 변수 이름 뒤에 `: type` 구문을 붙여 데이터 타입을 명시
    
    ```tsx
    let isDone:boolean =false;
    let decimal:number = 6;
    let color: string = 'blue';
    ```
    

### 구조적 타이핑

- 타입을 사용하는 언어에서 값이나 객체는 하나의 구체적인 타입을 가지고 있으며 타입은 이름으로 구분되고 컴파일 타임 이후에도 남아있다.
- 이것을 명목적으로 구체화한 타입시스템이라고 부르기도 한다.
- 타입스크립트에서 타입을 구분하는 방식은 다른 언어와는 다름
- **타입스크립트**는 구조로 타입을 구분하며 이것을 **구조적 타이핑**이라고 한다.

### 구조적 서브타이핑

- 타입스크립트의 타입은 값의 집합으로 생각할 수 있다.
- 따라서 타입스크립트에서는 특정 값이 string 또는 number 타입을 동시에 가질 수 있음
    
    ```tsx
    type stringOrNumber = string | number;
    ```
    
- 구조적 서브타이핑이란 객체가 가지고 있는 속성을 바탕으로 타입을 구분하는 것
- 이름이 다른 객체라도 가진 속성이 동일하다면 타입스크립트는 서로 호환이 가능한 동일한 타입으로 여긴다.
    
    ```tsx
    interface Pet{
    	name: string;
    }
    
    let cat = {name: 'Zag', age: 2 };
    function greet(pet: Pet) {
    	console.log("Hello, ", + pet.name)
    }
    
    greet(cat) // ✅ok
    ```
    
    - 타입을 명시하지 않은 `cat` 객체를 `greet()` 함수의 인자로 전달해도 코드는 정상적으로 실행된다.
    - `cat` 객체가 `Pet` 인터페이스가 가지고 있는 `name` 속성을 가지고 있어 `pet.name`의 방식으로 `name` 속성에 접근할 수 있기 때문

### 자바스크립트를 닮은 타입스크립트

- 명목적 타이핑을 채택한 언어에서는 이름으로 타입을 구분하기 때문에 구조가 같더라도 이름이 다르면 다른 파입을 취급하기 때문에 동일성을 확인하는 과정에서 구조적 타이핑에 비해 조금 더 안전하다.
- 그럼에도 타입스크립트가 구조적 타이핑을 채택한 이유는 타입스크립트가 자바스크립트를 모델링한 언어이기 때문
- 자바스크립트는 본질적으로 덕 타이핑(duck typing)을 기반으로 하는데, 타입스크립트가 이런 동작을 그대로 모델링한다.
- 덕 타이핑이란 어떤 타입에 부합하는 변수와 메서드를 가질 경우 해당 타입이 속하는 것으로 간주하는 방식.
- 덕 타이핑과 구조적 타이핑은 모두 객체 변수, 메서드 같은 필드를 기반으로 타입을 검사한다는 공통점이 있지만 타입을 검사하는 시점이 다름.
    - 덕 타이핑은 동적 타이핑에서, 구조적 타이핑은 정적 타이핑에서 사용된다.

### 구조적 타이핑의 결과

```tsx
interface Cube {
  width: number;
  height: number;
  depth: number;
}

function addLines(c: Cube) {
  let total = 0;
  
  for(const axios of Object.keys(c)) {
    const length = c[axios]
    total+=length
  }
}
```


- 타입스크립트는 c[axios]가 어떤 속성을 지닐지 알 수 없으며 c[axios] 타입을 number라고 확정지을 수 없어 에러를 발생 시킴
- 이러한 한계를 극복하고자 **유니온** 같은 방법이 생겨남

### 타입스크립트의 점진적 타입 확인

- 점진적 타입 검사란 컴파일 타임에 타입을 검사하면서 필요에 따라 타입 선언 생략을 허용하는 방식
- 타입 선언을 생략하면 암시적 타입 변환(`any`)이 일어난다.
- 이러한 특징은 자바스크립트 코드를 타입스크립트로 마이그레이션할 때 유용하지만 정적 타입의 정확성을 100% 보장하지 않는다.

### 자바스크립트 슈퍼셋으로서의 타입스크립트

- 타입스크립트는 자바스크립트 코드에 정적인 타이핑을 추가한 것으로 자바스크립트의 상위 집합이다.
- 따라서 모든 자바스크립트 코드는 타입스크립트라고 볼 수 있지만 반대의 경우는 아니다.
- 타입스크립트는 타입을 명시하는 문법을 가지고 있기 때문에 모든 타입스크립트 코드가 자바스크립트 코드인 것은 아니다.

### 값 vs 타입

- 값은 프로그램이 처리하기 위해 메모리에 저장하는 모든 데이터
- 문자열, 숫자, 변수, 매개변수 등이 값에 해당
- 함수 역시 변수에 할당할 수 있는 값이다.
- `type`으로 선언한 내용은 자바스크립트 런타임에서 제거되기 때문에 값 공간과 타입 공간은 서로 충돌하지 않음
    
    ```tsx
    type Developer = { isWorking: true };
    const Developer = { isTyping: true };
    ```
    
- 타입스크립트에서는 값과 타입이 함께 사용되며 별도의 네임스페이스에 존재
- 타입스크립트는 개발자가 작성한 코드 문맥을 파악해 스스로 값 또는 타입으로 해석하기 때문에 맥락에 따라 값 공간과 타입 공간을 혼동할 수 있음
    
    ```tsx
    function email({
      person,
      subject,
      body,
    }: {
      person: Person;
      subject: string;
      body: string;
    }) {}
    ```
    
    - 갑과 타입을 구분해서 작성해야한다.
- 값과 타입 공간이 동시에 존재하는 `class`와 `enum`
    
    ```tsx
    class Developer {
      name: string;
      domain: string;
    
      constructor(name: string, domain: string) {
        this.name = name;
        this.domain = domain;
      }
    }
    
    const me: Developer = new Developer('zig', 'frontend');
    ```
    
    ```tsx
    enum Direction {
      Up, // 0
      Down, // 1
      Left, // 2
      Right, // 3
    }
    ```
    

- `enum` 과 `const enum`
    - `enum`
        
        ```tsx
        enum Colors {
          Red,
          Green,
          Blue,
        }
        ```
        
        - `enum`이 컴파일되면 다음과 같은 코드가 생성된다.
        
        ```tsx
        	"use strict";
        var Colors;
        (function (Colors) {
          Colors[Colors["Red"] = 0] = "Red";
          Colors[Colors["Green"] = 1] = "Green";
          Colors[Colors["Blue"] = 2] = "Blue";
        })(Colors || (Colors = {}));
        ```
        
        - `Colors`는 객체로 변환되며, 런타임 시점에도 `Colors` 객체에 접근할 수 있음
        - 런타임에 열거형 객체가 필요할 때 유용하지만 코드가 더 길어지고 메모리를 차지
    - `const enum`
        
        ```tsx
        const enum Colors {
          Red,
          Green,
          Blue,
        }
        ```
        
        - TypeScript에서 `const enum`을 컴파일할 때, 실제 열거형 이름 대신 열거형 값으로 대체하여 실제 객체는 생성되지 않는다.
        - 즉, 참조하는 곳에 값만 인라인하여 추가적인 객체 생성이 없어 메모리와 성능 최적화가 가능하지만 런타임에 열거형 객체에 직접 접근할 수는 없다.
- 트리 쉐이킹(tree-shaking) : 자바스크립트, 타입스크립트에서 사용하지 않는 코드를 삭제하는 방식. 모듈 번들러에서 번들링 작업을 수행할 때 사용하지 않는 코드를 삭제함
- 타입스크립트에서 `typeof`, `instanceof`, 타입 단언을 사용해 타입을 확인할 수 있다.
    - 값에서 사용된 `typeof` 는 자바스크립트 런타임의 `typeof` 연산자가 되며, 타입에서 사용된 `typeof` 는 값을 읽고 타입스크립트를 반환

### as const를 왜 사용할까!

- `as const` 도입 전, `const`로 정의된 배열과 객체는 기본적으로 느슨한 타입추론이 된다.
    
    ```tsx
    const xs = ["hi","hello"] // string[]
    
    function f(x: "hi" | "hello") {}
    
    const x = xs[0]
    f(x); // 'string' 형식의 인수는 '"hi" | "hello"' 형식의 매개 변수에 할당될 수 없습니다.
    ```
    
    값이 변경될 수 있는 일반적인 타입(`primitive type(string)`)으로 추론 된 것이기 때문에 정확한 리터럴타입(`"hi" | "hello”`)이 아니라 타입 에러가 발생한다.
    
- `as const`를 사용한다면?
    
    ```tsx
    const a = ["hi", "hello", "world"] as const;
    
    // const xs: ('hi' | 'hello')[] = ["hi", "hello"];
    
    ```
    
    - 타입 선언에 대한 편리함을 제공

- `as const`가 없다면
    
    ```tsx
    const xs: ('hi' | 'hello')[] = ["hi", "hello"];
    
    function f(x: "hi" | "hello") {}
    
    xs.shift()
    xs.shift()
    
    // xs == []
    const x = xs[0] // "hi"| "hello" 라고 예상
    f(x); 
    ```
    
    - 위 코드에서는 타입시스템이 `xs[0]` 의 `undefined` 가능성을 예상하지 못한다.
    - **`as const`가 없다면 `const`로 선언한 배열이나 객체가 변경되었을 때, 이를 타입시스템으로 감지하기 어렵다. →** `as const` 으로 배열이나 객체의 불변성을 유지할 수 있다.
    - `as const` 는 이러한 문제를 `readonly` 를 붙임으로서 이러한 동작이 가능하게 한다.
    
    → `as const` 는 편의를 위해 도입이 되었지만 정확하게 동작하기 위해 `readonly` 를 붙인다.
    
- 즉,  `const`로 정의된 배열이나 객체는 기본적으로 느슨한 타입으로 추론되는데 이는 값이 변경될 수 있는 일반적인 타입으로 추론되기 때문에 불변성을 보장하기 어렵다. `as const`를 사용하여 타입을 단언함으로서 배열과 객체의 값이 읽기 전용으로 변경되고, 배열과 객체의 불변성을 보장할 수 있다.

<br/>

## 3. 원시 타입

- `boolean`
    - `true`와 `false` 값만 할당할 수 있는 `boolean` 타입
    - `Truthy/Falsy` 값은 `boolean` 원시 값이 아니므로 타입스크립트에서도 `boolean` 타입에 해당하지 않는다.
- `undefined`
    - 초기화되지 않은 값이나 존재하지 않음
- `null`
    - 명시적, 의도적으로 값이 비어있음을 나타냄
- `number`
    - 자바스크립트의 숫자에 해당하는 모든 원시 값을 할당
    - `NaN` 이나 `Infinity`도 포함
- `bigInt`
    - 정밀도가 제한되지 않은 정수형 타입으로, 큰 수를 다루기 위해 설계된 원시타입
    - `number` 타입과 직접 연산할 수 없음
    - 소수점이 없는 정수
- `string`
    - 문자열을 할당할 수 있는 타입, 공백 해당
- `symbol`
    - 어떤 값과도 중복되지 않는 유일한 값 생성 가능

<br/>

## 4. 객체 타입

- 원시타입에 속하지 않는 모든 값
- `object`
    - 모든 타입 값을 유동적으로 할당할 수 있어 정적 타이핑의 의미가 크게 퇴색되기 때문에 사용하는 것을 지양
- `{}`
    - 객체 리터럴 방식으로 객체를 생성할 때 사용
- `array`
    - 하나의 타입만 가질 수 있어 자바스크립트보다 더 엄격함
- `type`과 `interface`
    - 객체를 타이핑하기 위해 사용
- `function`
    - 함수를 함수타입으로 지정
    - 함수의 매개변수도 별도 타입으로 지정해야함
    
    ```tsx
    function add(a:number, b: number): number {
    	return a+b
    }
    ```
    
    - 함수 자체의 타입을 지정할 때는 호출 시그니처를 사용
    
    ```tsx
    type add =(a:number, b:number) => number
    ```
